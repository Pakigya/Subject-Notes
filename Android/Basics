Manifest file : Describes the fundamental characteristics of the app and defines each of its components. Eg: permissions,
activity, service, receiver etc.

build.gradle => To configure how the Gradle tools compile and build your app.
MainActivity extends AppCompatActivity

Intent : An Intent is an object that provides runtime binding between separate components, such as two activities. The Intent represents an app’s "intent to do something." 
Activity class is subclass of Context.
An Intent can carry data types as key-value pairs called extras.
Common uses of Intent
-------------------------
1. To start an Activity
2. To start a service
3. To deliver a broadcast

Supporting different languages and cultures : Add support in res folder. Each directory's name should adhere to the following format:
<resource type>-b+<language code>[+<country code>]    Eg: mipmap-b+es+ES for Spain

Supporting different sizes :  four generalized sizes: small, normal, large, xlarge
                              four generalized densities: low (ldpi), medium (mdpi), high (hdpi), extra high (xhdpi)
                              
MyProject/
    res/
        layout/
            main.xml
        layout-large/
            main.xml
Provide bitmap images that are properly scaled.
xhdpi: 2.0
hdpi: 1.5
mdpi: 1.0 (baseline)
ldpi: 0.75
This means that if you generate a 200x200 image for xhdpi devices, you should generate the same resource in 150x150 for hdpi, 
100x100 for mdpi, and 75x75 for ldpi devices.

Fragment : A modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or 
remove while the activity is running (sort of like a "sub activity" that you can reuse in different activities).
One difference when creating a Fragment is that you must use the onCreateView() callback to define the layout. 
One fragment should never talk directly to another fragment - instead go through the parent activity.
Fragments communicate via Intents.

In short, fragments live inside activities, and each activity can host many fragments. Like activities, they have a specific lifecycle, 
unlike activities, they are not top-level application components. Advantages of fragments include code reuse and modularity 
(e.g., using the same list view in many activities), including the ability to build multi-pane interfaces (mostly useful on tablets). 
The main disadvantage is (some) added complexity. You can generally achieve the same thing with (custom) views in a non-standard and less robust way.

Following are important points about a fragment:

A fragment has its own layout and its own behavior with its own lifecycle callbacks.
You can add or remove fragments in an activity while the activity is running.
You can combine multiple fragments in a single activity to build a multi-pane UI.
A fragment can be used in multiple activities.
The fragment life cycle is closely related to the lifecycle of its host activity.
When the activity is paused, all the fragments available in the acivity will also be stopped.
A fragment can implement a behavior that has no user interface component.
Fragments were added to the Android API in Android 3 (Honeycomb) with API version 11.

Eg: Two fragments, displayed in different configurations for the same activity on different screen sizes. On a large screen, 
both fragments fit side by side, but on a handset device, only one fragment fits at a time so the fragments must replace each other as the user navigates.
Views have their own life cycle too.

The main reason to use Fragments are for the backstack and lifecycle features. Eg: Using the back button
Otherwise, custom views are more light weight and simpler to implement

Bundle : Bundle is used to pass data between Activities. You can create a bundle, pass it to Intent that starts the activity which then can be used from the destination activity.
Intent intent = new...
Intent(getApplicationContext(), SecondActivity.class);
intent.putExtra("myKey", AnyValue);  
startActivity(intent);

You can get the passed values by doing:

Bundle extras = intent.getExtras(); 
String tmp = extras.getString("myKey");

Content Providers vs SQLite
-----------------------------
Storing your data in a database is one good way to persist your data, but there's a caveat in Android-databases created in 
Android are visible only to the application that created them. That is to say, a SQLite database created on Android by one 
application is usable only by that application, not by other applications.
So, if you need to share data between applications, you need to use the content provider model as recommended in Android.
The main difference is: when your app needs to share information to another apps, use Content-Provider. SQLite only storage data for the app who creates it

BroadcastReceiver : Receives broadcast. Eg: ACTION_BOOT_COMPLETED 

AsyncTask vs Handler
-------------------------
If you are doing something isolated related to UI, for example downloading data to present in a list, go ahead and use AsyncTask.
If you are doing multiple repeated tasks, for example downloading multiple images which are to be displayed in ImageViews
(like downloading thumbnails) upon download, use a task queue with Handler.
Both are internally implemented using Thread of Java.
AsyncTask enables proper and easy use of the UI thread. This class allows you to perform background operations and publish results 
on the UI thread without having to manipulate threads and/or handlers.
AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long 
periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask.

There are two main uses for a Handler: 
(1) to schedule messages and runnables to be executed as some point in the future; and 
(2) to enqueue an action to be performed on a different thread than your own.

Service vs Asyntask
---------------------
In short, Service for time consuming tasks, AsyncTask for short-lived tasks

WebViews
-----------
A common scenario in which using WebView is helpful is when you want to provide information in your application that you 
might need to update, such as an end-user agreement or a user guide. Within your Android application, you can create an 
Activity that contains a WebView, then use that to display your document that's hosted online.
Another scenario in which WebView can help is if your application provides data to the user that always requires an Internet 
connection to retrieve data, such as email. In this case, you might find that it's easier to build a WebView in your Android 
application that shows a web page with all the user data, rather than performing a network request, then parsing the data and 
rendering it in an Android layout. Instead, you can design a web page that's tailored for Android devices and then implement a 
WebView in your Android application that loads the web page.

Performance considerations
-------------------------------
1. Making ListView Scrolling Smooth : The key to a smoothly scrolling ListView is to keep the application’s main thread (the UI thread) free from heavy processing. 
Ensure you do any disk access, network access, or SQL access in a separate thread. 
2. Hold View Objects in a View Holder : Your code might call findViewById() frequently during the scrolling of ListView, which can slow 
down performance. Even when the Adapter returns an inflated view for recycling, you still need to look up the elements and update them. 
A way around repeated use of findViewById() is to use the "view holder" design pattern.
A ViewHolder object stores each of the component views inside the tag field of the Layout, so you can immediately access them without 
the need to look them up repeatedly. First, you need to create a class to hold your exact set of views.
3. Delayed Loading of Views  :Sometimes your layout might require complex views that are rarely used. Whether they are item details, 
progress indicators, or undo messages, you can reduce memory usage and speed up rendering by loading the views only when they are needed.
4. Create a Re-usable Layout( define in an xml )

Adapters
-------------
Well adapters in Android are basically a bridge between the UI components and the data source that fill data into the UI Component
For example, Lists (UI Component) get populated by using a list adapter, from a data source array.

SharedPreferences - Key Value pairs
----------------------------------------
If you have a relatively small collection of key-values that you'd like to save, you should use the SharedPreferences APIs.
A SharedPreferences object points to a file containing key-value pairs and provides simple methods to read and write them. 
Each SharedPreferences file is managed by the framework and can be private or shared.

SharedPreferences vs Bundle
-------------------------------
If you're using SharedPreferences anyways because you have to keep the values when the app is closed, then just use SharedPreferences all of the time. 
However, to save storage space on the user's phone, use a bundle if you only need to share the data between activities and it can be scrapped after the app is close
SharedPreferences are useful when you want to use some data across all activity. The problem with storing data in a global variable instead
of sharedPrefernces is that, data will be lost when you close the application.

Implict Intents vs Explicit Intents
------------------------------------
Implicit Intents do not directly specify the Android components which should be called , it only specifies action to be performed.
An Uri can be used with the implicit intent to specify data type.

Intent intent = new Intent(ACTION_VIEW,Uri.parse("http://www.google.com");
this will cause web browser to open a webpage . Android system searches for all components which are registered for the specific 
action and the data type.If many components are found then the user can select which component to use.

When using implicit intents it is necessary to check for some conditions before. However, it is possible that there are no applications 
that can handle your intent. In this case, your application will crash when you invoke startActivity(). To avoid this, before calling 
startActivity() you should first verify that there is at least one application registered in the system that can handle the intent. 
To do this use resolveActivity() on your intent object:

Explicit intents are used in the application itself wherein one activity can switch to other activty.
Example Intent intent = new Intent(this,Target.class); this causes switching of activity from current context to the target activity.
Explicit Intents can also be used to pass data to other activity using putExtra method and retrieved by target activity by getIntent().getExtras() methods...

Explicit Intents are generally used within an application when we know the name of class to call.
ANR vs Crash
--------------
ANR (A pplication N ot R esponding )is due to handling long running task in Main Thread(UI thread).If the main thread is 
stopped for more than 5 sec you get ANR.
Crash are due to exception and error like Nullpoint,classNotfound, typecast ,parse error etc. ANR also causes crash of application.
Note:Never run long running task on UI thread

Relative Layout vs Linear Layout
---------------------------------
Android need layout to contain all view in proper format. Linear layout is one of them. As per name Linear layout is a view group 
that aligns all children in a single direction, vertically or horizontally. We have to specify layout direction “horizontal” 
or “vertical ” using attribute android:orientation

RelativeLayout is a view group that displays child views in relative positions. The position of each view can be specified as relative 
to sibling elements (such as to the left-of or below another view) or in positions relative to the parent RelativeLayout area
(such as aligned to the bottom, left or center).

SQLite vs SQL
---------------
SQLite does not compete with client/server databases. SQLite competes with fopen().
For Client/Server Applications, High-volume Websites, Very large datasets and High Concurrency, use traditional RDMS. Else use SQLite
SQLite generally does not have a separate server process. SQLite is file-based, unlike other databases, like SQL Server and MySQL which are server-based.
All data is cached in SQLite
SQLite only supports a single writer at a time (meaning the execution of an individual transaction). It locks the entire database when
it needs to write.

Steps in SQLite
----------------
Create "SQLiteDatabase" object.
Open or Create database and create connection.
Perform insert, update or delete operation.
Create Cursor to display data from table of database.
Close the database connectivity.

R(resource) file
-------
Android R.java is an auto-generated file by aapt (Android Asset Packaging Tool) that contains resource IDs for all the resources of res/ directory. 
If you create any component in the activity_main.xml file, id for the corresponding component is automatically created in this file.

assets vs raw folder
-----------------------
In one line, the files in the raw/ directory are not compiled by the platform, are assigned a resource ID and cannot be grouped into 
sub-folders whereas if you want the otherwise use the assets/ directory.
Example : External fonts can be placed in assets folder.

Directory structure in Android
-------------------------------
src - src files
gen - genrated files. Cotains the R file
bin - apk
libs 
res - layout, values
project properties 
Android manifest

Lifecyle
-----------
1. onCreate
2. onStart
3. onResume
Activity Running
4. onPause : Called when another activity comes to the foreground
5. onStop : When activity is no longer visible
6. onDestroy : The activity is being finished or destroyed by the system

startActivityForResult() : Sometimes you want to get a result back from an activity when it ends
If your application cannot work without a specific feature being available on the system, you can prevent users from installing your 
app with a <uses-feature> element in your app’s manifest file to specify a non-negotiable dependency.

Types of broadcast
------------------
Types :- Local,Normal,Ordered and Sticky

Normal Broadcast
:- use sendBroadcast()
:- asynchronous broadcast
:- any receiver receives broadcast not any particular order

Ordered Broadcast
:- use sendOrderedBroadcast()
:- synchronous broadcast
:- receiver receives broadcast in priority base
:- we can also simply abort broadcast in this type

Local Broadcast
:- use only when broadcast is used only inside same process

Sticky Broadcast
:- normal broadcast intent is not available any more after is was send and processed by the system.
:- use sendStickyBroadcast(Intent)
:- the corresponding intent is sticky, meaning the intent you are sending stays around after the broadcast is complete.
:- because of this others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter).
:- apart from this same as sendBroadcast(Intent).

The value of a sticky broadcast is the value that was last broadcast and is currently held in the sticky cache. This is not the value of a broadcast 
that was received right now. I suppose you can say it is like a browser cookie that you can access at any time. The sticky broadcast is 
now deprecated.
One example of a sticky broadcast sent via the operating system is ACTION_BATTERY_CHANGED. When you call registerReceiver() for that 
action -- even with a null BroadcastReceiver -- you get the Intent that was last broadcast for that action. Hence, you can use this to 
find the state of the battery without necessarily registering for all future state changes in the battery.

An AsyncTask is not tied to the life cycle of the Activity that contains it. So, for example, if you start an AsyncTask inside an 
Activity and the user rotates the device, the Activity will be destroyed (and a new Activity instance will be created) but the 
AsyncTask will not die but instead goes on living until it completes.
Then, when the AsyncTask does complete, rather than updating the UI of the new Activity, it updates the former instance of the Activity
(i.e., the one in which it was created but that is not displayed anymore!). This can lead to an Exception 
(of the type java.lang.IllegalArgumentException: View not attached to window manager if you use, for instance, findViewById to retrieve a view inside the Activity).
There’s also the potential for this to result in a memory leak since the AsyncTask maintains a reference to the Activty, which prevents 
the Activity from being garbage collected as long as the AsyncTask remains alive.
For these reasons, using AsyncTasks for long-running background tasks is generally a bad idea . Rather, for long-running 
background tasks, a different mechanism (such as a service) should be employed.

Service vs intent Service
-------------------------------
Service class uses the application's main thread, while IntentService creates a worker thread and uses that thread to run the service.
IntentService creates a queue that passes one intent at a time to onHandleIntent(). Thus, implementing a multi-thread should be made by 
extending Service class directly.
Service class needs a manual stop using stopSelf(). Meanwhile, IntentService automatically stops itself when there is no intent in 
queue, all queued intents are handled. 

The Service runs in background but it runs on the Main Thread of the application.
The IntentService runs on a separate worker thread

IPC mechanisms in Android include:
Intents (with Bundles included)
Binders or Messengers with a Service
BroadcastReceivers
Since android is meant for embedded and small devices, we should not use serialization for IPC, rather we can use BINDERs 
which internally uses parcels. Parcel is a sort of light weight serialization by using shared memory concept.
To pass data between activities, services, and receivers use only Bundles. Don't go for either serialization or binders. 
Binders are specifically used only for binder services where 2 processes will communicate.

AIDL (Android Interface Definition Language) is similar to other IDLs you might have worked with. It allows you to define the 
programming interface that both the client and service agree upon in order to communicate with each other using interprocess communication (IPC).

