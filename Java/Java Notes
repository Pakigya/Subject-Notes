/* Notes have been assembled from Geeksforgeeks and various other stackoverflow links. Used only for self study*/.

Naming Convetion : 
Java follows CamelCase naming convention. Naming conventions vary according to different requirements :
1. Classes and Intefaces: Nouns in mixedCase with the first character capitalized and the first letter of every internal word capitalized.
Eg: HelloWorld
2. Methods : Verbs with first letter in small case and the internal first word of every subsequent word capitalized.
Eg: sayHello()
3. Variables : Small case. Cannot start with underscore or dollar sign.
Eg: length
4. Constant Variables : All in uppercase with words separated by underscore.
Eg: STRING_LENGTH
5. Packages : Eg: com.samsung.noida.framework

What exactly does public static void main(String[] args) signify?
public : JVM can call the public method from anywhere.
static : Main method is called without any object.
void : Does not return anything.
main : Method name chosen by JVM
String[] : The main method takes in an array of String objects as the argument.

System.out.println() => System : Class    out : variable of type output stream    println() : method

The code is first compiled using javac which creates a bytecode version of the program. Then the JVM is called to execute the 
bytecode using java command.

The main method as we saw, was run by JVM. JVM is a part of JRE( Java RunTime Enviornment). 
JVM consists of :
1. Class loader : Responsible for
    - Loading
    - Linking
    - Initialization : Initializes static variables and static blocks
    
    Types of Class Loader :
    a. Bootstrap class loader : Eg: String.class.getClassLoader() will return null as String class is loaded by Bootstrap class
                                loader and bootstrap class loader is not a java object.
    b. Extension class loader
    c. System / Application class loader : Eg: MyCustomClass.class.getClassLoader() will print something like : sun.misc.Launcher$AppClassLoader@73d16e93
    as the Custom class is loaded by Application class loader.
    
2. JVM Area : Includes
    - Method Area : One Method Area per JVM
    - Heap Area : One Heap Area per JVM
    - Stack area : Single stack corresponding to each thread.
    - PC Register : Stores address of thread. One per thread.
    - Native Method Stack : One per thread
    
3. Execution Engine : Consists of
    - Interpreter
    - Just In Time Compiler ( JIT )
    - Garbage Collector
4. JNI
5. Native Method libraries

JDK : JRE + Development Tools
JRE : JVM + Library Classes( Eg: RMI , Collections, JNI and so on)

FileName and ClassName should be same only when the class is Public. Else it does not need to be same.

import keyword can only be used to import from the classpath( director ). Outside the classpath import keyword cannot be used. 
-cp build option can be used while compiling and executing program to import from another classpath. 

Identifiers : Class Name , Method Name , Variable Names or a label.
Java is a statically typed language as opposed to say Python. Thus in Java we have to first declare an integer to assign an integer 
to it unlike in Python.

By default fraction values are double in java. To use instead float, add f at the end.
8 primitive data types in Java : boolean , byte , char , float , long , int , float , double

Enum stand for enumerated data types. 
enum Color {
    RED , GREEN , BLACK;
}
is internally represented as : 
Class Color {
    private static final Color RED = new Color();
    private static final Color GREEN = new Color();
    private static final Color BLACK = new Color();
}
Every enum constant is always public static final.
Enums cannot extend any other class as they extend java.lang.ENUM class. Some methods available are:
values() , ordinal(), valueOf().

There are 3 types of variables in Java.
1. Local Variables : Inside a method/block/constructor
2. Instance variables : Non static variables and declared in a class outside any method, block or constructor.
                        One instance per each object.
3. Static Variables : Also called Class Variables. One instance per class.

class MyClass {
    static int val1; // Static variable
    int val2;       // Instance variable
 }

Static local variables are not allowed in Java. So for instance if there is a method called :
void sayHello() {
    static int a;
}
Above code generates an error.

Acess Modifiers
---------------------------

Acess Modifiers               Public      Protected       Default         Private
Inside the class                Yes         Yes             Yes             Yes
Subclass inside the package     Yes         Yes             Yes             No
Subclass outside the package    Yes         Yes             No              No
World                           Yes         No              No              No  

Default has Package level access.

while loop is an entry controlled loop as opposed to do-while which is an exit controlled loop.
switch statement can take a string as opposed to an integer( from JDK 7 ). Hence a code like below works:
public static void tryFunc( String s) {
        switch(s)
        {
            case "Hello" :
                System.out.println("elective courses : Advance english, Algebra");
                break;
            default:
                System.out.println("no match");
        }
    }
    
 Forward declaration is not necessary in Java. Hence a method can be called before it is defined.
 
 Widening primitve conversion happens only when there is '+' operator.
 Thus System.out.print("A" + "B" + 'C') prints ABC.
 System.out.println('A' + 'B' + "C") prints 131C.
 
 Type conversion in Java
 -------------------
Widening Or Automatic Type conversion :  Byte - > Short - > Int - > Long -> Float - > Double
Narrowing or explicit conversion ( Need to typecast ) : From any bigger one to a smaller one.
If integer is converted to byte, gives result as %256.

Type Promotion : If there is an expression that we are trying to evaluate and it contains an operand of higher one, it is converted 
into one of higher one. Example : integer * float will give float.

Java does not support goto. However, it does support label which is inserted just before a loop. Can break there.

outer:
for( int i = 0; i < 10; i++)
    for( int j = 0; j < 5; j++)
        if( j == 1)
            break outer;
            

Anonymous Objects in Java
-----------------------------
If an object is created but not assigned( i.e we do not hold a reference for the object), it is called an anonymous object.
For instance Animal a = new Animal() vs new Animal(). The latter is an anonymous object. Used generally for immediate method calling.

Different ways of creating an object in Java
-------------------------------------------------
1. Using new keyword
2. Using clone method
3. Using Class.forName(String className) methodd
4. Using deserialization

To call the method associated with any object, we have to create an object. We cannot call the method just by using the reference.
Thus for instance if an Animal class has a method called runs(), to call it we have to create an object of Animal and call as shown.
Animal a = new Animal();
a.runs()
If instead we would do the following, we will get compiler error.
Animal a;
a.runs();

If we want to swap two class objects but do not know the members of another class, then we can create a wrapper class and swap.

Class Car {
    int name;
    Car( String name)
        this.name = name;
}

Class CarWrapper {
    Car c;
    CarWrapper (Car c )
        this.c = c;
}

swap(c1 , c2) will help to swap the two car objects provided c1 and c2 are of type CarWrapper. If they are of type Car, cannot swap.

Inheritance
--------------
In Java, grandparent's members cannot be directly accessed using super.super call. Instead, the child can call the parent class' method
which in turn needs to call the grandparent's method using super.
Constructors are not members and hence are not inherited by subclasses. But the constructor of the superclass can be invoked from the
subclass. Private members can only be accessed of superclass by public or protected setter and getter options.

Encapsultion( Data hiding )
-------------
Protective shield that shields the data from being accessed by code outside the shield.
Achieved by declaring private variables and using setters and getters( public methods) to access them.
Advantages :
- data hiding
- can give only read access or write access
- Reusability
- Unit testing is easier 

Dynamic Method Dispatch or Runtime Polymorphism
-------------------------------------------------
No runtime polymorphism possible for data members.

class A {
    int x = 10;
}
class B extends A {
    int x = 20;
}
int main() {
    A a = new B();
    System.out.println(a.x);    // Prints 10 as variables are not overriden
}

Superclass reference variable can be used to refer to subclass.
Example if A is the superclass and B extends A then,
A a = new B() can be used to call B's method.

Association vs Composition vs Aggregation
-------------------------------------------
Association : Relationship between 2 different classes established through their objects.
Can be one to one , one to many , many to one or many to many.
Aggregation and Composition are the two types of association.

              Aggregation                                                       Composition
      ------------------------------------------------------------------------------------------------------
           Has A relationship                                                Part of relationship
           Unidirectional                                                       Bidirectional
    Both entries can survive individually                                   Entries cannot surivive individually
    Eg: Institute has departments. Departments have students   
    Eg: Libraries can have number of books. If library gets destroyed, so do books.
    
    Can have a list of books in Library.
    
Non access modifier or specifiers in Java are : static , final , transient , abstract , synchronized , transient, volatile and native.

Overloading : Compile Time or static Polymorphism
Overloading : Different parameters or type of parameters. Cannot overload according to return type.

If the base class overrides the static function of base class, there is no run time polymorphism as the base class method
won't be called.
Eg: class Base {
    public static void print() {
        System.out.println("base class");
    }
}
class Derived extends Base { 
    public static void print() {
        System.out.println("Derived class");
    }
}

Base b1 = new Derived();
b1.print(); // Prints base class as static methods won't be overriden

For class or static variables the call is decided at compiled time based on the type of reference.
For non class or instance variables, the call is decided at run time based on 
    
User defined operator overloading is not allowed in Java. Java internally overloads operators. For instance, + for concatenation.
Overriding - Run Time and Overloading - Compile Time
Methods that throw different exceptions are still not overloaded as they still have same signatures.

class A {
    public int print() {
        System.out.println("print1");
        return 0;
    }
    public long print() {
        System.out.println("print2");
        return 1;
    }
    public static void main(String[] args ) {
        A a = new A();
        a.print();  // Generates compiler error as method overloading must have different parameters. Can't overload based on return type
    }
}

Below code generates compiler error as methods that throw different exceptions are not overloaded.
public int print(String data) throws IOException {
    return 0;
}
public int print(String data) throws Exception {
    return 1;
}

Run Time Polymorphism : Type of object being referred to( not the reference type ) that determines which version of an overridden method
will be called.
Rules for overriding
-------------------------------------
1. The overriding method can allow more but not less than access than the overridden method. For instance, protected method
after being overridden cannot be made private but can be made public.
2. Final methods cannot be overridden.
3. Static methods cannot be overridden.
4. Private methods cannot be overridden.
5. Overriding methods must have same return type( or subtype : also called covariant return )
6. Overridden method can be invoked using the super keyword.
7. We cannot override constructor.
8. Overriding and Exceptions
    a. If the super class overridden method does not throw an exception, subclass overriding method can only throw unchecked
    exception. If it throws checked exception, it will lead to compile time error.
    Eg : void print() method in Parent when overridden, if it throws an exception say void print() throws ArithmenticException is ok as
    it is an unchecked exception. If however, it throws 'Exception', we get a compile time error.
    
    b. If the super class does throw an exception, then subclass one can throw same or subclass exception. Throwing parent exception will
    lead to compile time error.
    For instance if void print() throws RunTimeException in parent and subclass is void print() throws Exception we get an error.

9. Abstract methods in an interface or abstract class are meant to be overridden.
10. The presence of synchronized/stricfp modifier with method has no effect on overriding rules.

In C++, we need virtual keyword to achieve overriding. In Java, methods are virtual by default.
Multilevel method overriding is possible in Java.

Covariant Return type : Possible to have different return type for an overriding method in base class and child class. However, child
class return type should be sub-type of parent's return type.

Object class in Java has the following methods :
1. toString() : Called when we try to print any object reference.
        HelloWorld hello = new HelloWorld();
        System.out.println(hello.toString()); // Prints HelloWorld@2a139a55
If instead we had overridden toString() method, we would have printed whatever toString() method returned.
        public String toString() {
            return "Hello"; // Would instead print Hello when we print the object reference
        } 
       
2. hashCode() : As can be seen from the previous example, HelloWorld@2a139a55 is printed on printing hello object.
If we want to assign our own unique hashcode value to the object we can do so.
     @Override
    public int hashCode()
    {
        return roll_no;     // As a roll number is generally unique for a student , can be used as a hashcode.
    }
 
3. equals() : Compares given object to this object.
For instance below code will always print "Not equal" if we do not override equals method.
        HelloWorld c1 = new HelloWorld(10, 15);
        HelloWorld c2 = new HelloWorld(10, 15);
        if (c1.equals(c2)) {
            System.out.println("Equal ");
        } else {
            System.out.println("Not Equal ");
        }
If however, we want to compare the two objects and their values, we can use equals method and define our own implementation.
When we override equals method , always recommended to override hashCode() method too. 

4. getClass()
        Object obj = new String("GeeksForGeeks");
        Class c = obj.getClass();
        System.out.println("Class of Object obj is : "      // Prints       Class of Object obj is : java.lang.String
                           + c.getName());
5. finalize() : Used to free up resources, destroy references( garbage collection ).
6. clone()
7. notify()
8. notifyAll()

Object class can be used to assign any data type( like in Python).
Thus following are all valid :
Object str = "Hello";
Object myInt = 10;
Object myFloat = 10.45;

Initializer block contains code that is always executed when an instance is created. Thus used to declare the common parts of various
constructors of a class.

class A {
    {
        System.out.println("Class A");
    }
    A() {
        System.out.println("Class A without arguments");
    }
    A( int a ) {
        System.out.println("Class A with arguments");
    }
}

Now when we call A object's constructor, Class A would be printed in both cases, with argument and without argument.

If a class B extends Class A and we create a new object of type class B , then the constructor of Class A is also called.

                Static Binding                                                           Dynamic Binding
----------------------------------------------------------------------------------------------------------------------------------
private, static and final members( methods and variables )                  virtual methods( methods are virtual by default)
     Uses type information for binding                                                 Uses object information for binding
    Eg: Overloaded methods                                                              Eg: Overridden method
    
Autoboxing : Autoboxing is the automatic conversion that Java makes between Primitive types and their corresponding Object Wrapper class.
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(i);
In the above code snippet, integer primitive is convert into Wrapper class.
Unboxing : Converting from wrapper class back to primitive type.  Eg : int absVal = absoluteValue(i); where i is of type Integer

Java is not a fully Object Oriented language like Smalltalk because there are primitive type supports, static keyword means that 
object is not required to call methods and Wrapper class provide autoboxing and unboxing.


Abstract Classes and Interfaces:
------------------------------------------
Interfaces are useful when we do not know anything about the implementation but know the contract that the implementer 
should have to accomplish the task.
Abstract classes are useful when we know partial implementation , say 3 out of 5 methods.

Since Java 8, interfaces can have default and static methods.
Abstract classes can have non final variables whereas in interfaces variables are by default public, final and static.

Suppose we need to add a new method into an existing interface. We could not do it prior to Java 8. Now however, we can
add a default method meaning other classes that implement it do not need to implement it. Thus forward compatibility.

Static methods can be added in interfaces which can be called independently without an object.
interface in1
{
    final int a = 10;
    static void display()
    {
        System.out.println("hello");
    }
}
 
// A class that implements interface.
class testClass implements in1
{
    // Driver Code
    public static void main (String[] args)
    {
        in1.display();  // Prints hello
    }
}

An interface can extend another interface but only one. All methods in interface are public and abstract. All field are
public , static and final.
Eg: 
interface A {
    int a;  // Will generate a compile time error since variables are public , static and final by default and final variables need to be declared.
}

We cannot declare class or interface with private or protected access specifier. Nested interfaces and classes can have all access specifiers.

Abstract classes
-----------------------
1. Instance of abstract class cannot be created, they can be referenced though.
2. An abstract class can have constructors. Constructor of abstract class is called when instance of the class inherting the abstract
class is created.
3. Abstract class can be created without any abstract methods. This allows us to create classes that cannot be instantiated but inherited.
4. Abstract class can also have final methods which means class inherting from it, cannot override the function.

Abstract classes do not have constructors. An instance of interface cannot be created and final methods cannot be overridden.
Comparator interface
----------------------
Comparator interface is used to order objects of user defined types.

Nested interfaces can be accessed as follows:

class A {
    interface AA {
        void printMethod();
    }
}

class B implements A.AA {
    public void printMethod() {
        System.out.println("Nested interface");
    }
}

Now we can call as follows:
A.AA aObject;
B bObject = new B();
aObject = bObject;
aObject.show();

Nested Classes 
-----------------------
Increases encapsulation. The scope of nested class is only within that class.
Nested classes can either be :
1. Static Nested Class
2. Non static nested class
    a. Local Inner class
    b. Anonymous Inner class
    
 If say we have an OuterClass and it contains a static inner class called StaticNestedClass, then we can call the method display
 inside the inner class as follows :
 // accessing a static nested class
 OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
 nestedObject.display();

Static nested class do not have access to other members( non static variables and methods) of the enclosing class as it has to access
it through an object.
Non static nested class( inner classes) have access to all members.

Declaring a Local Inner class: A local inner class can be declared within a block. This block can be either a method body, 
initialization block, for loop or even an if statement.

Anonymous Inner Class : No name. Only a single object is created for it.
Eg: Age a1 = new Age() {
    public void getAge() {
        System.out.println("Age is " + age);   
     }
}

Functional Interface: An interface that contains only abstract method is called functional interface. Eg: Runnable , ActionListener,
Comparable

Marker Interface : It is an empty interface with no fields or methods. Eg: Clonnable , Serializable and Remote Intefaces.
Why use marker interface when it has nothing?
In earlier versions of Java, Marker Interfaces were the only way to declare metadata about a class. For example, the Serializable Marker Interface 
lets the author of a class say that their class will behave correctly when serialized and deserialized.
In modern Java, marker interfaces have no place. They can be completely replaced by Annotations, which allow for a very flexible metadata capability.

Important Java packages are java.io , java.util and java.lang.

MultiThreading in Java
-------------------------------
Multithreading : Concurrent execution of two or more parts of a program for concurrent execution.
Threads can be created in two wasy:
1. Extending the Thread class
2. Implementing the Runnable interface

class A extends Thread {
    public void run() {
    
    }
}
A a = new A();
A.start();

class A implements Runnable {
    public void run() {
    
    }

}
Thread A = new Thread(new A());
A.start()

If we extend Thread class , we cannot extend any other class. However, we can achieve basic functionality of a thread by 
extending Thread class because it provides basic functionalities like yield(), interrupt() etc.

Main Thread : Main thread is created automatically when our program is started. We can use Thread.currentThread() to get
reference of this thread once the program starts.
A main thread can enter deadlock by using the join method.
Thread.currentThread.join() causes a deadlock as the main thread is waiting for itself to die.

We can prevent the execution of a thread by the following methods:
1. yield() : If suppose 3 threads are there such that one takes 5 hours and the other takes only 5 mins to execute, the second
will have to wait 5 hours to just finish 5 mins of work. In such case, yield method can be used to run the more important thread.
By calling the yield method, the thread is saying to the scheduler that it is ready to pause its execution. The thread scheduler
can ignore or it can give the processor to a thread with higher priority.
The thread which runs the yield method will run into Runnable() state from the Running state. 
The underlying platform must provide support for preemptive scheduling if we are using the yield method.

2. sleep() : Current thread sleeps for the specified time

yield() vs sleep()
yield:() indicates that the thread is not doing anything particularly important and if any other threads or processes need to be run, they can. Otherwise, the current thread will continue to run.
sleep(): causes the thread to definitely stop executing for a given amount of time; if no other thread or process needs to be run, the CPU will be idle (and probably enter a power saving mode).

3. join (): If join() is called on a Thread instance, the currently running thread will be blocked until the Thread instance has finished executing.

Thread t1 = new Thread(new EventThread("e1"));
t1.start();
Thread e2 = new Thread(new EventThread("e2"));
t2.start();

while (true) {
    try {
        t1.join(); // 1
        t2.join(); // 2  These lines (1,2) are in in public static void main
        break;
    }
}
t1.join() means, t1 says something like "I want to finish first". Same is the case with t2. No matter who started t1 or t2 thread (in this case the main method), main will wait until t1 and t2 finish their task.
However, an important point to note down, t1 and t2 themselves can run in parallel irrespective of the join call sequence on t1 and t2. It is the main/daemon thread that has to wait.

=> join will stop the current thread until the thread being called with join() is done executing.
=> interrupt will interrupt the thread it is being called on, causing InterruptedException.
=> yield allows a context switch to other threads, so this thread will not consume the entire CPU usage of the process.

If we say thread.sleep(1000), that thread will sleep for 1000 milliseconds for sure, whereas with yield() there is no such guarantee. 
This is useful for thread scheduling, since the thread which calls yield() may very well selected immediately again for running.

Syncronized keyword is used so that only one thread can access shared resources at a time.
// Only one thread can execute at a time. 
// sync_object is a reference to an object
// whose lock associates with the monitor. 
// The code is said to be synchronized on
// the monitor object
synchronized(sync_object)
{
   // Access shared variables and other
   // shared resources
}

Syncronization is achieved in Java using a concept of monitors. Only one thread can own a monitor at a time. All other threads
attempting to enter the locked monitor will be suspended until the first thread exists the monitor.

Inter thread communication
----------------------------------
Polling : Process of checking repeatedly till a condition becomes true is called polling.
How does Java handle polling?
1. Wait : Releases the lock on shared resources and waits till some other thread invokes notify
2. Notify : Wakes up one single thread that called the wait on the same object.Calling notify does not give up resource
3. Notifyall : Wakes up all threads that called wait on the same object.

Notify vs notifyall
---------------------
If only one of the thread can do useful work( eg. acquire lock) , example in case of mutually exclusive lock, better to use notify
instead of notifyAll.

Why do we need start() method instead of directly running run() ?
The purpose of start is to create a separate call stack for the thread. A separate call stack is created by it, and then run() 
method is called.

// Java code to see that all threads are
// pushed on same stack if we use run()
// instead of start().
class ThreadTest extends Thread
{
  public void run()
  {
    try
    {
      // Displaying the thread that is running
      System.out.println ("Thread " +
                Thread.currentThread().getId() +
                " is running");
 
    }
    catch (Exception e)
    {
      // Throwing an exception
      System.out.println ("Exception is caught");
    }
  }
}
 
// Main Class
public class Main
{
  public static void main(String[] args)
  {
    int n = 8;
    for (int i=0; i<n; i++)
    {
      ThreadTest object = new ThreadTest();
 
      // start() is replaced with run() for
      // seeing the purpose of start
      object.run();
    }
  }
}

The output with start() is :
Thread 11 is running
Thread 13 is running
Thread 10 is running
Thread 12 is running
Thread 14 is running
Thread 15 is running
Thread 16 is running
Thread 17 is running

whereas output wtih run() is :
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running

