/* Notes have been assembled from Geeksforgeeks and various other stackoverflow links*/.

Naming Convetion : 
Java follows CamelCase naming convention. Naming conventions vary according to different requirements :
1. Classes and Intefaces: Nouns in mixedCase with the first character capitalized and the first letter of every internal word capitalized.
Eg: HelloWorld
2. Methods : Verbs with first letter in small case and the internal first word of every subsequent word capitalized.
Eg: sayHello()
3. Variables : Small case. Cannot start with underscore or dollar sign.
Eg: length
4. Constant Variables : All in uppercase with words separated by underscore.
Eg: STRING_LENGTH
5. Packages : Eg: com.samsung.noida.framework

What exactly does public static void main(String[] args) signify?
public : JVM can call the public method from anywhere.
static : Main method is called without any object.
void : Does not return anything.
main : Method name chosen by JVM
String[] : The main method takes in an array of String objects as the argument.

System.out.println() => System : Class    out : variable of type output stream    println() : method

The code is first compiled using javac which creates a bytecode version of the program. Then the JVM is called to execute the 
bytecode using java command.

The main method as we saw, was run by JVM. JVM is a part of JRE( Java RunTime Enviornment). 
JVM consists of :
1. Class loader : Responsible for
    - Loading
    - Linking
    - Initialization : Initializes static variables and static blocks
    
    Types of Class Loader :
    a. Bootstrap class loader : Eg: String.class.getClassLoader() will return null as String class is loaded by Bootstrap class
                                loader and bootstrap class loader is not a java object.
    b. Extension class loader
    c. System / Application class loader : Eg: MyCustomClass.class.getClassLoader() will print something like : sun.misc.Launcher$AppClassLoader@73d16e93
    as the Custom class is loaded by Application class loader.
    
2. JVM Area : Includes
    - Method Area : One Method Area per JVM
    - Heap Area : One Heap Area per JVM
    - Stack area : Single stack corresponding to each thread.
    - PC Register : Stores address of thread. One per thread.
    - Native Method Stack : One per thread
    
3. Execution Engine : Consists of
    - Interpreter
    - Just In Time Compiler ( JIT )
    - Garbage Collector
4. JNI
5. Native Method libraries

JDK : JRE + Development Tools
JRE : JVM + Library Classes( Eg: RMI , Collections, JNI and so on)

FileName and ClassName should be same only when the class is Public. Else it does not need to be same.

import keyword can only be used to import from the classpath( director ). Outside the classpath import keyword cannot be used. 
-cp build option can be used while compiling and executing program to import from another classpath. 

Identifiers : Class Name , Method Name , Variable Names or a label.
Java is a statically typed language as opposed to say Python. Thus in Java we have to first declare an integer to assign an integer 
to it unlike in Python.

By default fraction values are double in java. To use instead float, add f at the end.
8 primitive data types in Java : boolean , byte , char , float , long , int , float , double

Enum stand for enumerated data types. 
enum Color {
    RED , GREEN , BLACK;
}
is internally represented as : 
Class Color {
    private static final Color RED = new Color();
    private static final Color GREEN = new Color();
    private static final Color BLACK = new Color();
}
Every enum constant is always public static final.
Enums cannot extend any other class as they extend java.lang.ENUM class. Some methods available are:
values() , ordinal(), valueOf().

There are 3 types of variables in Java.
1. Local Variables : Inside a method/block/constructor
2. Instance variables : Non static variables and declared in a class outside any method, block or constructor.
                        One instance per each object.
3. Static Variables : Also called Class Variables. One instance per class.

class MyClass {
    static int val1; // Static variable
    int val2;       // Instance variable
 }

Static local variables are not allowed in Java. So for instance if there is a method called :
void sayHello() {
    static int a;
}
Above code generates an error.

Acess Modifiers
---------------------------

Acess Modifiers               Public      Protected       Default         Private
Inside the class                Yes         Yes             Yes             Yes
Subclass inside the package     Yes         Yes             Yes             No
Subclass outside the package    Yes         Yes             No              No
World                           Yes         No              No              No  

Default has Package level access.

while loop is an entry controlled loop as opposed to do-while which is an exit controlled loop.
switch statement can take a string as opposed to an integer( from JDK 7 ). Hence a code like below works:
public static void tryFunc( String s) {
        switch(s)
        {
            case "Hello" :
                System.out.println("elective courses : Advance english, Algebra");
                break;
            default:
                System.out.println("no match");
        }
    }
    
 Forward declaration is not necessary in Java. Hence a method can be called before it is defined.
 
 Widening primitve conversion happens only when there is '+' operator.
 Thus System.out.print("A" + "B" + 'C') prints ABC.
 System.out.println('A' + 'B' + "C") prints 131C.
 
 Type conversion in Java
 -------------------
Widening Or Automatic Type conversion :  Byte - > Short - > Int - > Long -> Float - > Double
Narrowing or explicit conversion ( Need to typecast ) : From any bigger one to a smaller one.
If integer is converted to byte, gives result as %256.

Type Promotion : If there is an expression that we are trying to evaluate and it contains an operand of higher one, it is converted 
into one of higher one. Example : integer * float will give float.

Java does not support goto. However, it does support label which is inserted just before a loop. Can break there.

outer:
for( int i = 0; i < 10; i++)
    for( int j = 0; j < 5; j++)
        if( j == 1)
            break outer;
            

Anonymous Objects in Java
-----------------------------
If an object is created but not assigned( i.e we do not hold a reference for the object), it is called an anonymous object.
For instance Animal a = new Animal() vs new Animal(). The latter is an anonymous object. Used generally for immediate method calling.

Different ways of creating an object in Java
-------------------------------------------------
1. Using new keyword
2. Using clone method
3. Using Class.forName(String className) methodd
4. Using deserialization

To call the method associated with any object, we have to create an object. We cannot call the method just by using the reference.
Thus for instance if an Animal class has a method called runs(), to call it we have to create an object of Animal and call as shown.
Animal a = new Animal();
a.runs()
If instead we would do the following, we will get compiler error.
Animal a;
a.runs();

If we want to swap two class objects but do not know the members of another class, then we can create a wrapper class and swap.

Class Car {
    int name;
    Car( String name)
        this.name = name;
}

Class CarWrapper {
    Car c;
    CarWrapper (Car c )
        this.c = c;
}

swap(c1 , c2) will help to swap the two car objects provided c1 and c2 are of type CarWrapper. If they are of type Car, cannot swap.

Inheritance
--------------
In Java, grandparent's members cannot be directly accessed using super.super call. Instead, the child can call the parent class' method
which in turn needs to call the grandparent's method using super.
Constructors are not members and hence are not inherited by subclasses. But the constructor of the superclass can be invoked from the
subclass. Private members can only be accessed of superclass by public or protected setter and getter options.

Encapsultion( Data hiding )
-------------
Protective shield that shields the data from being accessed by code outside the shield.
Achieved by declaring private variables and using setters and getters( public methods) to access them.
Advantages :
- data hiding
- can give only read access or write access
- Reusability
- Unit testing is easier 

Dynamic Method Dispatch or Runtime Polymorphism
-------------------------------------------------
No runtime polymorphism possible for data members.

class A {
    int x = 10;
}
class B extends A {
    int x = 20;
}
int main() {
    A a = new B();
    System.out.println(a.x);    // Prints 10 as variables are not overriden
}

Superclass reference variable can be used to refer to subclass.
Example if A is the superclass and B extends A then,
A a = new B() can be used to call B's method.

Association vs Composition vs Aggregation
-------------------------------------------
Association : Relationship between 2 different classes established through their objects.
Can be one to one , one to many , many to one or many to many.
Aggregation and Composition are the two types of association.

              Aggregation                                                       Composition
      ------------------------------------------------------------------------------------------------------
           Has A relationship                                                Part of relationship
           Unidirectional                                                       Bidirectional
    Both entries can survive individually                                   Entries cannot surivive individually
    Eg: Institute has departments. Departments have students   
    Eg: Libraries can have number of books. If library gets destroyed, so do books.
    
    Can have a list of books in Library.
    
Non access modifier or specifiers in Java are : static , final , transient , abstract , synchronized , transient, volatile and native.

Overloading : Compile Time or static Polymorphism
Overloading : Different parameters or type of parameters. Cannot overload according to return type.

If the base class overrides the static function of base class, there is no run time polymorphism as the base class method
won't be called.
Eg: class Base {
    public static void print() {
        System.out.println("base class");
    }
}
class Derived extends Base { 
    public static void print() {
        System.out.println("Derived class");
    }
}

Base b1 = new Derived();
b1.print(); // Prints base class as static methods won't be overriden

For class or static variables the call is decided at compiled time based on the type of reference.
For non class or instance variables, the call is decided at run time based on 
    
User defined operator overloading is not allowed in Java. Java internally overloads operators. For instance, + for concatenation.
Overriding - Run Time and Overloading - Compile Time
Methods that throw different exceptions are still not overloaded as they still have same signatures.

class A {
    public int print() {
        System.out.println("print1");
        return 0;
    }
    public long print() {
        System.out.println("print2");
        return 1;
    }
    public static void main(String[] args ) {
        A a = new A();
        a.print();  // Generates compiler error as method overloading must have different parameters. Can't overload based on return type
    }
}
