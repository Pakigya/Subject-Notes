/* Notes have been assembled from Geeksforgeeks and various other stackoverflow links. Used only for self study*/.

Naming Convetion : 
Java follows CamelCase naming convention. Naming conventions vary according to different requirements :
1. Classes and Intefaces: Nouns in mixedCase with the first character capitalized and the first letter of every internal word capitalized.
Eg: HelloWorld
2. Methods : Verbs with first letter in small case and the internal first word of every subsequent word capitalized.
Eg: sayHello()
3. Variables : Small case. Cannot start with underscore or dollar sign.
Eg: length
4. Constant Variables : All in uppercase with words separated by underscore.
Eg: STRING_LENGTH
5. Packages : Eg: com.abc.noida.framework

What exactly does public static void main(String[] args) signify?
public : JVM can call the public method from anywhere.
static : Main method is called without any object.
void : Does not return anything.
main : Method name chosen by JVM
String[] : The main method takes in an array of String objects as the argument.

System.out.println() => System : Class    out : variable of type output stream    println() : method

The code is first compiled using javac which creates a bytecode version of the program. Then the JVM is called to execute the 
bytecode using java command.

The main method as we saw, was run by JVM. JVM is a part of JRE( Java RunTime Enviornment). 
JVM consists of :
1. Class loader : Responsible for
    - Loading
    - Linking
    - Initialization : Initializes static variables and static blocks
    
    Types of Class Loader :
    a. Bootstrap class loader : Eg: String.class.getClassLoader() will return null as String class is loaded by Bootstrap class
                                loader and bootstrap class loader is not a java object.
    b. Extension class loader
    c. System / Application class loader : Eg: MyCustomClass.class.getClassLoader() will print something like : sun.misc.Launcher$AppClassLoader@73d16e93
    as the Custom class is loaded by Application class loader.
    
2. JVM Area : Includes
    - Method Area : One Method Area per JVM
    - Heap Area : One Heap Area per JVM
    - Stack area : Single stack corresponding to each thread.
    - PC Register : Stores address of thread. One per thread.
    - Native Method Stack : One per thread
    
3. Execution Engine : Consists of
    - Interpreter
    - Just In Time Compiler ( JIT )
    - Garbage Collector
4. JNI
5. Native Method libraries

JDK : JRE + Development Tools
JRE : JVM + Library Classes( Eg: RMI , Collections, JNI and so on)

FileName and ClassName should be same only when the class is Public. Else it does not need to be same.

import keyword can only be used to import from the classpath( director ). Outside the classpath import keyword cannot be used. 
-cp build option can be used while compiling and executing program to import from another classpath. 

Identifiers : Class Name , Method Name , Variable Names or a label.
Java is a statically typed language as opposed to say Python. Thus in Java we have to first declare an integer to assign an integer 
to it unlike in Python.

By default fraction values are double in java. To use instead float, add f at the end.
8 primitive data types in Java : boolean , byte , char , float , long , int , float , double

Enum stand for enumerated data types. 
enum Color {
    RED , GREEN , BLACK;
}
is internally represented as : 
Class Color {
    private static final Color RED = new Color();
    private static final Color GREEN = new Color();
    private static final Color BLACK = new Color();
}
Every enum constant is always public static final.
Enums cannot extend any other class as they extend java.lang.ENUM class. Some methods available are:
values() , ordinal(), valueOf().

There are 3 types of variables in Java.
1. Local Variables : Inside a method/block/constructor
2. Instance variables : Non static variables and declared in a class outside any method, block or constructor.
                        One instance per each object.
3. Static Variables : Also called Class Variables. One instance per class.

class MyClass {
    static int val1; // Static variable
    int val2;       // Instance variable
 }

Static local variables are not allowed in Java. So for instance if there is a method called :
void sayHello() {
    static int a;
}
Above code generates an error.

Acess Modifiers
---------------------------

Acess Modifiers               Public      Protected       Default         Private
Inside the class                Yes         Yes             Yes             Yes
Subclass inside the package     Yes         Yes             Yes             No
Subclass outside the package    Yes         Yes             No              No
World                           Yes         No              No              No  

Default has Package level access.

while loop is an entry controlled loop as opposed to do-while which is an exit controlled loop.
switch statement can take a string as opposed to an integer( from JDK 7 ). Hence a code like below works:
public static void tryFunc( String s) {
        switch(s)
        {
            case "Hello" :
                System.out.println("elective courses : Advance english, Algebra");
                break;
            default:
                System.out.println("no match");
        }
    }
    
 Forward declaration is not necessary in Java. Hence a method can be called before it is defined.
 
 Widening primitve conversion happens only when there is '+' operator.
 Thus System.out.print("A" + "B" + 'C') prints ABC.
 System.out.println('A' + 'B' + "C") prints 131C.
 
 Type conversion in Java
 -------------------
Widening Or Automatic Type conversion :  Byte - > Short - > Int - > Long -> Float - > Double
Narrowing or explicit conversion ( Need to typecast ) : From any bigger one to a smaller one.
If integer is converted to byte, gives result as %256.

Type Promotion : If there is an expression that we are trying to evaluate and it contains an operand of higher one, it is converted 
into one of higher one. Example : integer * float will give float.

Java does not support goto. However, it does support label which is inserted just before a loop. Can break there.

outer:
for( int i = 0; i < 10; i++)
    for( int j = 0; j < 5; j++)
        if( j == 1)
            break outer;
            

Anonymous Objects in Java
-----------------------------
If an object is created but not assigned( i.e we do not hold a reference for the object), it is called an anonymous object.
For instance Animal a = new Animal() vs new Animal(). The latter is an anonymous object. Used generally for immediate method calling.

Different ways of creating an object in Java
-------------------------------------------------
1. Using new keyword
2. Using clone method
3. Using Class.forName(String className) methodd
4. Using deserialization

To call the method associated with any object, we have to create an object. We cannot call the method just by using the reference.
Thus for instance if an Animal class has a method called runs(), to call it we have to create an object of Animal and call as shown.
Animal a = new Animal();
a.runs()
If instead we would do the following, we will get compiler error.
Animal a;
a.runs();

If we want to swap two class objects but do not know the members of another class, then we can create a wrapper class and swap.

Class Car {
    int name;
    Car( String name)
        this.name = name;
}

Class CarWrapper {
    Car c;
    CarWrapper (Car c )
        this.c = c;
}

swap(c1 , c2) will help to swap the two car objects provided c1 and c2 are of type CarWrapper. If they are of type Car, cannot swap.

Inheritance
--------------
In Java, grandparent's members cannot be directly accessed using super.super call. Instead, the child can call the parent class' method
which in turn needs to call the grandparent's method using super.
Constructors are not members and hence are not inherited by subclasses. But the constructor of the superclass can be invoked from the
subclass. Private members can only be accessed of superclass by public or protected setter and getter options.

Encapsultion( Data hiding )
-------------
Protective shield that shields the data from being accessed by code outside the shield.
Achieved by declaring private variables and using setters and getters( public methods) to access them.
Advantages :
- data hiding
- can give only read access or write access
- Reusability
- Unit testing is easier 

Dynamic Method Dispatch or Runtime Polymorphism
-------------------------------------------------
No runtime polymorphism possible for data members.

class A {
    int x = 10;
}
class B extends A {
    int x = 20;
}
int main() {
    A a = new B();
    System.out.println(a.x);    // Prints 10 as variables are not overriden
}

Superclass reference variable can be used to refer to subclass.
Example if A is the superclass and B extends A then,
A a = new B() can be used to call B's method.

Association vs Composition vs Aggregation
-------------------------------------------
Association : Relationship between 2 different classes established through their objects.
Can be one to one , one to many , many to one or many to many.
Aggregation and Composition are the two types of association.

              Aggregation                                                       Composition
      ------------------------------------------------------------------------------------------------------
           Has A relationship                                                Part of relationship
           Unidirectional                                                       Bidirectional
    Both entries can survive individually                                   Entries cannot surivive individually
    Eg: Institute has departments. Departments have students   
    Eg: Libraries can have number of books. If library gets destroyed, so do books.
    
    Can have a list of books in Library.
    
Non access modifier or specifiers in Java are : static , final , transient , abstract , synchronized , transient, volatile and native.

Overloading : Compile Time or static Polymorphism
Overloading : Different parameters or type of parameters. Cannot overload according to return type.

If the derived class overrides the static function of base class, there is no run time polymorphism as the base class method
won't be called.
Eg: class Base {
    public static void print() {
        System.out.println("base class");
    }
}
class Derived extends Base { 
    public static void print() {
        System.out.println("Derived class");
    }
}

Base b1 = new Derived();
b1.print(); // Prints base class as static methods won't be overriden

The reason static methods cannot be overridden in Java is because method overriding only occurs in the context of dynamic( runtime)
lookup of methods whereas static classes are looked up at compile time.

For class or static variables the call is decided at compiled time based on the type of reference.
For non class or instance variables, the call is decided at run time based on type of object.
    
User defined operator overloading is not allowed in Java. Java internally overloads operators. For instance, + for concatenation.
Overriding - Run Time and Overloading - Compile Time
Methods that throw different exceptions are still not overloaded as they still have same signatures.

class A {
    public int print() {
        System.out.println("print1");
        return 0;
    }
    public long print() {
        System.out.println("print2");
        return 1;
    }
    public static void main(String[] args ) {
        A a = new A();
        a.print();  // Generates compiler error as method overloading must have different parameters. Can't overload based on return type
    }
}

Below code generates compiler error as methods that throw different exceptions are not overloaded.
public int print(String data) throws IOException {
    return 0;
}
public int print(String data) throws Exception {
    return 1;
}

Run Time Polymorphism : Type of object being referred to( not the reference type ) that determines which version of an overridden method
will be called.
Rules for overriding
-------------------------------------
1. The overriding method can allow more but not less than access than the overridden method. For instance, protected method
after being overridden cannot be made private but can be made public.
2. Final methods cannot be overridden.
3. Static methods cannot be overridden.
4. Private methods cannot be overridden.
5. Overriding methods must have same return type( or subtype : also called covariant return )
6. Overridden method can be invoked using the super keyword.
7. We cannot override constructor.
8. Overriding and Exceptions
    a. If the super class overridden method does not throw an exception, subclass overriding method can only throw unchecked
    exception. If it throws checked exception, it will lead to compile time error.
    Eg : void print() method in Parent when overridden, if it throws an exception say void print() throws ArithmenticException is ok as
    it is an unchecked exception. If however, it throws 'Exception', we get a compile time error.
    
    b. If the super class does throw an exception, then subclass one can throw same or subclass exception. Throwing parent exception will
    lead to compile time error.
    For instance if void print() throws RunTimeException in parent and subclass is void print() throws Exception we get an error.

9. Abstract methods in an interface or abstract class are meant to be overridden.
10. The presence of synchronized/stricfp modifier with method has no effect on overriding rules.

In C++, we need virtual keyword to achieve overriding. In Java, methods are virtual by default.
Multilevel method overriding is possible in Java.

Covariant Return type : Possible to have different return type for an overriding method in base class and child class. However, child
class return type should be sub-type of parent's return type.

class ShapeFactory {
        public Shape newShape() {}
}
class CircleFactory extends ShapeFactory {
        public Circle newShape() {}
} 

As can be seen from the above piece of code, newShape in ShapeFactory is returning Shape whereas newShape in CircleFactory is returning Circle.
   

Object class in Java has the following methods :
1. toString() : Called when we try to print any object reference.
        HelloWorld hello = new HelloWorld();
        System.out.println(hello.toString()); // Prints HelloWorld@2a139a55
If instead we had overridden toString() method, we would have printed whatever toString() method returned.
        public String toString() {
            return "Hello"; // Would instead print Hello when we print the object reference
        } 
       
2. hashCode() : As can be seen from the previous example, HelloWorld@2a139a55 is printed on printing hello object.
If we want to assign our own unique hashcode value to the object we can do so.
     @Override
    public int hashCode()
    {
        return roll_no;     // As a roll number is generally unique for a student , can be used as a hashcode.
    }
 
3. equals() : Compares given object to this object.
For instance below code will always print "Not equal" if we do not override equals method.
        HelloWorld c1 = new HelloWorld(10, 15);
        HelloWorld c2 = new HelloWorld(10, 15);
        if (c1.equals(c2)) {
            System.out.println("Equal ");
        } else {
            System.out.println("Not Equal ");
        }
If however, we want to compare the two objects and their values, we can use equals method and define our own implementation.
When we override equals method , always recommended to override hashCode() method too. 

4. getClass()
        Object obj = new String("GeeksForGeeks");
        Class c = obj.getClass();
        System.out.println("Class of Object obj is : "      // Prints       Class of Object obj is : java.lang.String
                           + c.getName());
5. finalize() : Used to free up resources, destroy references( garbage collection ).
6. clone()
7. notify()
8. notifyAll()

Object class can be used to assign any data type( like in Python).
Thus following are all valid :
Object str = "Hello";
Object myInt = 10;
Object myFloat = 10.45;

Initializer block contains code that is always executed when an instance is created. Thus used to declare the common parts of various
constructors of a class.

class A {
    {
        System.out.println("Class A");
    }
    A() {
        System.out.println("Class A without arguments");
    }
    A( int a ) {
        System.out.println("Class A with arguments");
    }
}

Now when we call A object's constructor, Class A would be printed in both cases, with argument and without argument.

If a class B extends Class A and we create a new object of type class B , then the constructor of Class A is also called.

                Static Binding                                                           Dynamic Binding
----------------------------------------------------------------------------------------------------------------------------------
private, static and final members( methods and variables )                  virtual methods( methods are virtual by default)
     Uses type information for binding                                                 Uses object information for binding
    Eg: Overloaded methods                                                              Eg: Overridden method
    
Autoboxing : Autoboxing is the automatic conversion that Java makes between Primitive types and their corresponding Object Wrapper class.
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(i);
In the above code snippet, integer primitive is convert into Wrapper class.
Unboxing : Converting from wrapper class back to primitive type.  Eg : int absVal = absoluteValue(i); where i is of type Integer

Java is not a fully Object Oriented language like Smalltalk because there are primitive type supports, static keyword means that 
object is not required to call methods and Wrapper class provide autoboxing and unboxing.


Abstract Classes and Interfaces:
------------------------------------------
Interfaces are useful when we do not know anything about the implementation but know the contract that the implementer 
should have to accomplish the task.
Abstract classes are useful when we know partial implementation , say 3 out of 5 methods.

Since Java 8, interfaces can have default and static methods.
Abstract classes can have non final variables whereas in interfaces variables are by default public, final and static.

Suppose we need to add a new method into an existing interface. We could not do it prior to Java 8. Now however, we can
add a default method meaning other classes that implement it do not need to implement it. Thus forward compatibility.

Static methods can be added in interfaces which can be called independently without an object.
interface in1
{
    final int a = 10;
    static void display()
    {
        System.out.println("hello");
    }
}
 
// A class that implements interface.
class testClass implements in1
{
    // Driver Code
    public static void main (String[] args)
    {
        in1.display();  // Prints hello
    }
}

An interface can extend another interface but only one. All methods in interface are public and abstract. All field are
public , static and final.
Eg: 
interface A {
    int a;  // Will generate a compile time error since variables are public , static and final by default and final variables need to be declared.
}

We cannot declare class or interface with private or protected access specifier. Nested interfaces and classes can have all access specifiers.

Abstract classes
-----------------------
1. Instance of abstract class cannot be created, they can be referenced though.
2. An abstract class can have constructors. Constructor of abstract class is called when instance of the class inherting the abstract
class is created.
3. Abstract class can be created without any abstract methods. This allows us to create classes that cannot be instantiated but inherited.
4. Abstract class can also have final methods which means class inherting from it, cannot override the function.

Abstract classes do not have constructors. An instance of interface cannot be created and final methods cannot be overridden.
Comparator interface
----------------------
Comparator interface is used to order objects of user defined types.

Nested interfaces can be accessed as follows:

class A {
    interface AA {
        void printMethod();
    }
}

class B implements A.AA {
    public void printMethod() {
        System.out.println("Nested interface");
    }
}

Now we can call as follows:
A.AA aObject;
B bObject = new B();
aObject = bObject;
aObject.show();

Nested Classes 
-----------------------
Increases encapsulation. The scope of nested class is only within that class.
Nested classes can either be :
1. Static Nested Class
2. Non static nested class
    a. Local Inner class
    b. Anonymous Inner class
    
 If say we have an OuterClass and it contains a static inner class called StaticNestedClass, then we can call the method display
 inside the inner class as follows :
 // accessing a static nested class
 OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
 nestedObject.display();

Static nested class do not have access to other members( non static variables and methods) of the enclosing class as it has to access
it through an object.
Non static nested class( inner classes) have access to all members.

Declaring a Local Inner class: A local inner class can be declared within a block. This block can be either a method body, 
initialization block, for loop or even an if statement.

Anonymous Inner Class : No name. Only a single object is created for it.
Eg: Age a1 = new Age() {
    public void getAge() {
        System.out.println("Age is " + age);   
     }
}
When a local class is used only once, consider using Anonymous Inner class.

Functional Interface: An interface that contains only one abstract method is called functional interface. Eg: Runnable , ActionListener,
Comparable

Marker Interface : It is an empty interface with no fields or methods. Eg: Clonnable , Serializable and Remote Intefaces.
Why use marker interface when it has nothing?
In earlier versions of Java, Marker Interfaces were the only way to declare metadata about a class. For example, the Serializable Marker Interface 
lets the author of a class say that their class will behave correctly when serialized and deserialized.
In modern Java, marker interfaces have no place. They can be completely replaced by Annotations, which allow for a very flexible metadata capability.

Important Java packages are java.io , java.util and java.lang.

MultiThreading in Java
-------------------------------
Multithreading : Concurrent execution of two or more parts of a program.
Threads can be created in two ways:
1. Extending the Thread class
2. Implementing the Runnable interface

class A extends Thread {
    public void run() {
    
    }
}
A a = new A();
A.start();

class A implements Runnable {
    public void run() {
    
    }

}
Thread A = new Thread(new A());
A.start()

If we extend Thread class , we cannot extend any other class. However, we can achieve basic functionality of a thread by 
extending Thread class because it provides basic functionalities like yield(), interrupt() etc.

Main Thread : Main thread is created automatically when our program is started. We can use Thread.currentThread() to get
reference of this thread once the program starts.
A main thread can enter deadlock by using the join method.
Thread.currentThread.join() causes a deadlock as the main thread is waiting for itself to die.

We can prevent the execution of a thread by the following methods:
1. yield() : If suppose 3 threads are there such that one takes 5 hours and the other takes only 5 mins to execute, the second
will have to wait 5 hours to just finish 5 mins of work. In such case, yield method can be used to run the more important thread.
By calling the yield method, the thread is saying to the scheduler that it is ready to pause its execution. The thread scheduler
can ignore or it can give the processor to a thread with higher priority.
The thread which runs the yield method will run into Runnable() state from the Running state. 
The underlying platform must provide support for preemptive scheduling if we are using the yield method.

2. sleep() : Current thread sleeps for the specified time

yield() vs sleep()
yield:() indicates that the thread is not doing anything particularly important and if any other threads or processes need to be run, they can. Otherwise, the current thread will continue to run.
sleep(): causes the thread to definitely stop executing for a given amount of time; if no other thread or process needs to be run, the CPU will be idle (and probably enter a power saving mode).

3. join (): If join() is called on a Thread instance, the currently running thread will be blocked until the Thread instance has finished executing.

Thread t1 = new Thread(new EventThread("e1"));
t1.start();
Thread e2 = new Thread(new EventThread("e2"));
t2.start();

while (true) {
    try {
        t1.join(); // 1
        t2.join(); // 2  These lines (1,2) are in in public static void main
        break;
    }
}
t1.join() means, t1 says something like "I want to finish first". Same is the case with t2. No matter who started t1 or t2 thread (in this case the main method), main will wait until t1 and t2 finish their task.
However, an important point to note down, t1 and t2 themselves can run in parallel irrespective of the join call sequence on t1 and t2. It is the main/daemon thread that has to wait.

=> join will stop the current thread until the thread being called with join() is done executing.
=> interrupt will interrupt the thread it is being called on, causing InterruptedException.
=> yield allows a context switch to other threads, so this thread will not consume the entire CPU usage of the process.

If we say thread.sleep(1000), that thread will sleep for 1000 milliseconds for sure, whereas with yield() there is no such guarantee. 
This is useful for thread scheduling, since the thread which calls yield() may very well selected immediately again for running.

Syncronized keyword is used so that only one thread can access shared resources at a time.
// Only one thread can execute at a time. 
// sync_object is a reference to an object
// whose lock associates with the monitor. 
// The code is said to be synchronized on
// the monitor object
synchronized(sync_object)
{
   // Access shared variables and other
   // shared resources
}

Syncronization is achieved in Java using a concept of monitors. Only one thread can own a monitor at a time. All other threads
attempting to enter the locked monitor will be suspended until the first thread exists the monitor.

Inter thread communication
----------------------------------
Polling : Process of checking repeatedly till a condition becomes true is called polling.
How does Java handle polling?
1. Wait : Releases the lock on shared resources and waits till some other thread invokes notify
2. Notify : Wakes up one single thread that called the wait on the same object. Calling notify does not give up resource.
3. Notifyall : Wakes up all threads that called wait on the same object.

Notify vs notifyall
---------------------
If only one of the thread can do useful work( eg. acquire lock) , example in case of mutually exclusive lock, better to use notify
instead of notifyAll.

Why do we need start() method instead of directly running run() ?
The purpose of start is to create a separate call stack for the thread. A separate call stack is created by it, and then run() 
method is called.

// Java code to see that all threads are
// pushed on same stack if we use run()
// instead of start().
class ThreadTest extends Thread
{
  public void run()
  {
    try
    {
      // Displaying the thread that is running
      System.out.println ("Thread " +
                Thread.currentThread().getId() +
                " is running");
 
    }
    catch (Exception e)
    {
      // Throwing an exception
      System.out.println ("Exception is caught");
    }
  }
}

What is the output of the following program:
public class HelloWorld{

     public static void main(String []args){
        try {
            Integer i = Integer.parseInt("-123S");
        } catch ( Exception e) {
            System.out.println("Yo");
        } catch( NumberFormatException e ) {
            System.out.println("yoyo");
        }
     }
}

Output:
Compiler error. NumberFormatException has already been caught.
 
// Main Class
public class Main
{
  public static void main(String[] args)
  {
    int n = 8;
    for (int i=0; i<n; i++)
    {
      ThreadTest object = new ThreadTest();
 
      // start() is replaced with run() for
      // seeing the purpose of start
      object.run();
    }
  }
}

The output with start() is :
Thread 11 is running
Thread 13 is running
Thread 10 is running
Thread 12 is running
Thread 14 is running
Thread 15 is running
Thread 16 is running
Thread 17 is running

whereas output wtih run() is :
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running
Thread 1 is running

The name of a thread can be changed by using the setName method.

Synchronization is only needed when the Object is mutable.
Java synchronization does not allow concurrent reads.
The entire method or only a block can be synchronized in java.

Producer Consumer Problem(Bounded Buffer Problem) : 
----------------------------------------------------------------
Multi process synchronization problem.
2 Processes : Producer and Consumer. Both share a common fixed size buffer used as a queue.
Producer : Produces data and puts it to the buffer and starts again
Consumer : Consumer consumes the data from the buffer, one piece at a time.
Caveat : Make sure that the producer does not try to add to the buffer if the buffer is full and the consumer does not try to 
consume if the buffer is empty.
Solution : If buffer is full, sleep( producer ). Next, when consumer consumes, notifies. Similarly, the consumer sleeps if empty.
Now, the producer will notify if item is added to the queue.

Thread Pool : A thread pool reuses previously created threads to execute current tasks and offers a solution to the problem of thread cycle overhead and resource thrashing.
So for instance, if there are 5 tasks to be done, it can be done by 2 threads where the 3rd task is taken up only after 1st or 2nd thread is done
executing or is idle.

A semaphore controls the access to a shared resource via a counter. Available in java.util.concurrent package.
Semaphore working
-----------------------------
If the semaphore’s count is greater than zero, then the thread acquires a permit, which causes the semaphore’s count to be decremented.
Otherwise, the thread will be blocked until a permit can be acquired.
When the thread no longer needs an access to the shared resource, it releases the permit, which causes the semaphore’s count to be incremented.
If there is another thread waiting for a permit, then that thread will acquire a permit at that time

CoundDownLatch enables you to make a thread wait till all other threads are done with their execution.

Pseudo code can be:

// Main thread starts
// Create CountDownLatch for N threads
// Create and start N threads
// Main thread waits on latch
// N threads completes there tasks are returns
// Main thread resume execution

Deadlock
-----------------
If threads are waiting for each other to finish, then the condition is known as Deadlock.
Deadlock condition is a complex condition which occurs only in case of multiple threads.

Daemon thread in Java
------------------------------
Daemon thread is a low priority thread that runs in background to perform tasks such as garbage collection.
setDaemon() method is used to convert a user thread to daemon thread.

Priority: When the only remaining threads in a process are daemon threads, the interpreter exits. This makes sense because when only daemon threads remain, there is no other thread for which a daemon thread can provide a service.
Usage: Daemon thread is to provide services to user thread for background supporting task.

CyclicBarrier : CyclicBarrier is used when multiple thread carry out different sub tasks and the output of these sub tasks need to be combined to form the final output. After completing its execution, threads call await() method and wait for other threads to reach the barrier.
Once all the threads have reached, the barriers then give the way for threads to proceed.
nce the number of threads that called await() equals numberOfThreads, the barrier then gives a way for the waiting threads.

Difference between a CyclicBarrier and a CountDownLatch
A CountDownLatch can be used only once in a program(until it’s count reaches 0).
A CyclicBarrier can be used again and again once all the threads in a barriers is released.

Callable vs Runnable : One feature lacking in  Runnable is that we cannot make a thread return result when it terminates, i.e. when run() completes. For supporting this feature, the Callable interface is present in Java.

For implementing Runnable, the run() method needs to be implemented which does not return anything, while for a Callable, the call() method needs to be implemented which returns a result on completion. Note that a thread can’t be created with a Callable, it can only be created with a Runnable.
Another difference is that the call() method can throw an exception whereas run() cannot.

Mark and Sweep : Garbage collection algorithm
2 steps:
1. Be able to detect all the unreachable objects
2. Reclaim the memory heap space used by the garbage objects.


To create the thread, a Runnable is required. To obtain the result, a Future is required.

The Java library has the concrete type FutureTask, which implements Runnable and Future, combining both functionality conveniently.
A FutureTask can be created by providing its constructor with a Callable

String vs StringBuilder vs StringBuffer
-----------------------------------------------
Objects of String are immutable, and objects of StringBuffer and StringBuilder are mutable.
StringBuffer and StringBuilder are similar, but StringBuilder is faster and preferred over StringBuffer for single threaded program. 
If thread safety is needed, then StringBuffer is used.

Why are Strings immutable in Java?
String is Immutable in Java because String objects are cached in String pool. Since cached String literals are shared between multiple 
clients there is always a risk, where one client's action would affect all another client.
Security: parameters are typically represented as String in network connections, database connection urls, usernames/passwords etc. If it were mutable, these parameters could be easily changed.
Synchronization and concurrency: making String immutable automatically makes them thread safe thereby solving the synchronization issues.
Caching: when compiler optimizes your String objects, it sees that if two objects have same value (a="test", and b="test") and thus you need only one string object (for both a and b, these two will point to the same object).
Class loading: String is used as arguments for class loading. If mutable, it could result in wrong class being loaded (because mutable objects change their state).

Garbage Collection
-------------------------
Objective : Free heap memory by destroying unreachable objects.
An object is said to be eligible for GC if it is unreachable.
Ways for requesting Java to run GC
1. System.gc()
2. Runtime.getRunTime().gc()\

finalize method : Just before freeing the memory, JVM calls finalize method for cleanup activities ( eg. closing database connectivity).

Ways to make an object eligible for GC
--------------------------------------------
1. Object created inside a method
2. Reassigning the reference variable.
3. Nullifying the reference variable.
4. Anonymous object

Mark and Sweep Algorithm : A garbage collection algorithm

Mark(root)
    If markedBit(root) = false then
        markedBit(root) = true
        For each v referenced by root       // Mark reachable nodes
             Mark(v)

Sweep()
For each object p in heap
    If markedBit(p) = true then
        markedBit(p) = false
    else
        heap.release(p)

Advantages of Mark and Sweep Algorithm
--------------------------------------
It handles the case with cyclic references, even in case of a cycle, this algorithm never ends up in an infinite loop.
There are no additional overheads incurred during the execution of the algorithm.

Disadvantages of Mark and Sweep Algorithm
-------------------------------------------
The main disadvantage of the mark-and-sweep approach is the fact that that normal program execution is suspended while the garbage collection algorithm runs.
Other disadvantage is that, after the Mark and Sweep Algorithm is run several times on a program, reachable objects end up being separated by many, small unused memory regions.

Island of Isolation:
------------------------
Object 1 references Object 2 and Object 2 references Object 1. Neither Object 1 nor Object 2 is referenced by any other object. That’s an island of isolation.
Basically, an island of isolation is a group of objects that reference each other but they are not referenced by any active object in the application. Strictly speaking, even a single unreferenced object
is an island of isolation too.

Buffered Reader vs Scanner
----------------------------------
In Scanner class if we call nextLine() method after any one of the seven nextXXX() method then the nextLine() doesn’t not read values from console and cursor will not come into console it will skip that step. The nextXXX() methods are nextInt(), nextFloat(), nextByte(), nextShort(), nextDouble(), nextLong(), next().
In BufferReader class there is no such type of problem. This problem occurs only for Scanner class, due to nextXXX() methods ignore newline character and nextLine() only reads newline character. If we use one more call of nextLine() method between nextXXX() and nextLine(), then this problem will not occur because nextLine() will consume the newline character

BufferedReader br = new BufferedReader(new
        InputStreamReader(System.in));
        System.out.println("Enter an integer");
        int a = Integer.parseInt(br.readLine());
        System.out.println("Enter a String");
        String b = br.readLine();
        System.out.printf("You have entered:- " + a +
                          " and name as " + b);
                          
Output:
Enter an integer
Enter a String
you have entered:- 50 and name as Geek

Hashmap vs Hashtable
1. HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
2. HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
3. HashMap is generally preferred over HashTable if thread synchronization is not needed

Why HashTable doesn’t allow null and HashMap does?
To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods

Scanner scn = new Scanner(System.in);
         System.out.println("Enter an integer");
         int a = scn.nextInt();
         System.out.println("Enter a String");
         String b = scn.nextLine();
         System.out.printf("You have entered:- "
                 + a + " " + "and name as " + b);
              
Output:
Enter an integer
Enter a String
You have entered:- 50 and name as


BufferedReader is synchronous while Scanner is not. BufferedReader should be used if we are working with multiple threads.
BufferedReader has significantly larger buffer memory than Scanner.
The Scanner has a little buffer (1KB char buffer) as opposed to the BufferedReader (8KB byte buffer), but it’s more than enough.
BufferedReader is a bit faster as compared to scanner because scanner does parsing of input data and BufferedReader simply reads sequence of characters.

ArrayList vs Vector
-----------------------
Snychronization : Vector : synchronized whrease ArrayList is not
Performance : ArrayList is faster as not synchronized
Data Growth : ArrayList ( 50%) vs Vector( 100 %)
Traversal : Enumeration and Iterator for Vectors vs Iterator( ArrayList )

Serialization and Deserialization in Java
--------------------------------------------
Serialization is a mechanism of converting the state of an object into a byte stream. 
Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory. 
This mechanism is used to persist the object.

The byte stream created is platform independent. So, the object serialized on one platform can be deserialized on a different platform.

Comparable vs Comparator
------------------------------
                    Comparable                                                                       Comparator
            - Compares itself with another object                                   - Capable of comparing two different objects
            - Natural Ordering ( Collections.sort(list) )                           - Represents ordering itself( Collections.sort(list , new Comparator() );
            - Can sort only based on one attribute                                  - Multiple attributes
            - compareTo                                                             - Override compare

TreeMap vs HashMap vs LinkedHashMap vs Hashtable
-----------------------------------------------------
HashMap : Random Ordering : O(1)
LinkedHashMap : Maintains insertion ordering , O(1)
TreeMap : Maintains natural ordering , O( log n) lookup
HashTable : Synchronized , Cannot have any null key or values

HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.

WeakHashMap :  In HashMap, we have a key and a value pair.
Even though the object is specified as key in hashmap, it does not have any reference and it is not eligible for garbage collection if it is associated with HashMap i.e. HashMap dominates over Garbage Collector.
 If object is specified as key doesn’t contain any references- it is eligible for garbage collection even though it is associated with WeakHashMap. i.e Garbage Collector dominates over WeakHashMap.

How to synchronize an ArrayList in Java?
- copyOnWriteMethod()
- synchronizedList() method

Java exceptions can either be :
- Built in exceptions
- User defined exceptions

If both base and derived classes are caught as exceptions then catch block of derived class must appear before the base class.

Checked vs Unchecked Exception:
-------------------------------------
If a client can reasonably be expected to recover from an exception, make it a checked exception. 
If a client cannot do anything to recover from the exception, make it an unchecked exception

Checked Exception : Compile Time ( eg: FileNotFoundException )
Unchecked Exception : RunTime ( eg: Arithmetic Exception)

Throw vs Throws vs Throwable
--------------------------------
Throw is used for throwing exception, throws (if I guessed correctly) is used to indicate that method can throw
particular exception, and the Throwable class is the superclass of all errors and exceptions in the Java

Error : Unchecked. Eg: OutofMemory, StackOVerflow
Exception : Can be checked or unchecked


Establishing JDBC Connection
1. Loading the driver
2. Create the connections
3. Create a statement
4. Execute the query
5. Close the connection

Difference between creating String as new vs literal?
When we create string with new() Operator, it’s created in heap and not added into string pool while String created using literal are created in String pool itself which exists in PermGen area of heap.
String s = new String("Test");
Does not  put the object in String pool , we need to call String.intern() method which is used to put  them into String pool explicitly. 
its only when you create String object as String literal e.g. String s = "Test" Java automatically put that into String poo
 
finally block will execute even if you put return statement in try block or catch block but finally block won't run if you call System.exit form try or catch.

How do you ensure that N thread can access N resources without deadlock?
If you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. 

Volatile Keyword in Java
-----------------------------
 // volatile keyword here makes sure that
   // the changes made in one thread are 
   // immediately reflect in other thread

FileReader vs FileInputStream
---------------------------------
FileReader - Reads in characters
FileInputStream - Reads in bytes

Private constructor : Used for creating singleton classes.

class Singleton
{
    // static variable single_instance of type Singleton
    private static Singleton single_instance = null;
 
    // variable of type String
    public String s;
 
    // private constructor restricted to this class itself
    private Singleton()
    {
        s = "Hello I am a string part of Singleton class";
    }
 
    // static method to create instance of Singleton class
    public static Singleton getInstance()
    {
        if (single_instance == null)
            single_instance = new Singleton();
 
        return single_instance;
    }
}
 
// Driver Class
class Main
{
    public static void main(String args[])
    {
        // instantiating Singleton class with variable x
        Singleton x = Singleton.getInstance();
 
        // instantiating Singleton class with variable y
        Singleton y = Singleton.getInstance();
 
        // instantiating Singleton class with variable z
        Singleton z = Singleton.getInstance();
 
        // changing variable of instance x
        x.s = (x.s).toUpperCase();
 
        System.out.println("String from x is " + x.s);
        System.out.println("String from y is " + y.s);
        System.out.println("String from z is " + z.s);
        System.out.println("\n");
 
        // changing variable of instance z
        z.s = (z.s).toLowerCase();
 
        System.out.println("String from x is " + x.s);
        System.out.println("String from y is " + y.s);
        System.out.println("String from z is " + z.s);
    }
}

Output:
--------
String from x is HELLO I AM A STRING PART OF SINGLETON CLASS
String from y is HELLO I AM A STRING PART OF SINGLETON CLASS
String from z is HELLO I AM A STRING PART OF SINGLETON CLASS


String from x is hello i am a string part of singleton class
String from y is hello i am a string part of singleton class
String from z is hello i am a string part of singleton class



